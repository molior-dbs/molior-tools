#!/bin/sh

. /usr/lib/molior-tools/molior.sh.inc

APTLY_OVERRIDE=0
LIST_ONLY=0
ask_cleanup=1
user_abort=0
deploy_all=0
keep_log=0
no_color=0
unstable_sources=0
dist=stable
lvm_rename_existing=0
DEPLOYMENT_SHA256=0
OVERLAY_VERSION=""
OVERLAY_AUTO=0
VARIANT=""
MOLIOR_PROJECTINFO_FILE=""
src_pkg_only=0
output_build_vars=0
omit_local_suffix=0
debug_mode=0
docker_login_registries=""
deploy_conf_level=0
include_file_level=0

MOLIOR_TOOLS_VERSION=`cat /usr/lib/molior-tools/version`

usage()
{
  echo "molior-tools $MOLIOR_TOOLS_VERSION"
  echo
  echo "Usage: $0 [OPTIONS] PROJECT VERSION"
  echo "Options:"
  echo "  -l                List deployment variants"
  echo "  -n PACKAGE_NAME   Package name (Default: PROJECT)"
  echo "  -s SOURCE_DIR     Use local source tree (Default: download source package)"
  echo "  -v VARIANT        Deployment variant to generate (Default: ask)"
  echo "  -p PRJSRC_FILE    Do not download project source from molior sever, use file contents"
  echo "  -m MOLIOR_SERVER  Molior server to use (Default in ~/.moliorrc)"
  echo "  -a APTLY_SERVER   Aptly server to use (Default in ~/.moliorrc)"
  echo "  -A                Override project apt sources with APTLY_SERVER"
  echo "  -V PKG_VERSION    Pin pkg version to install. Dangerous, use with care!"
  echo "  -O                Automatically find top level package in the available projectversions"
  echo "  -o OVERLAY_BASE   Specify overlay base and fetch top level package from there"
  echo "  -c                Cleanup on error (Default: ask)"
  echo "  -f                Build all variants (Default: ask)"
  echo "  -F OUTPUT_FILE    Custom deployment output's filename"
  echo "  -d                Debug APT package resolver. Print debug output to stdout instead of file"
  echo "  -t                Text output only, do not print colored output"
  echo "  -r                Keep rootfs of final deployment (to be used for -i)"
  echo "  -i ROOTFS_TAR     Use existing rootfs (tar) as base for post install (tar created with -r)"
  echo "  -L                Keep log file"
  echo "  -U                Use unstable APT sources (CI Builds)"
  echo "  -u                Use unstable top level package (INSTALL_PACKAGE in deploy file)"
  echo "  -S                Only download source package"
  echo "  -D                Output build variables"
  echo "  -C                Omit +local suffix for local builds"
  echo "  -T TMPDIR         Use TMPDIR (Default: \$MOLIOR_TMPDIR env variable or /tmp)"
  echo
  if [ -n "$1" ]; then
    echo $1
  fi
  echo
  exit 1
}

origopts=$@
while getopts "n:s:v:p:m:a:V:o:F:b:i:rtAlcfdOLUuSDCT:" opt; do
  case $opt in
    n)
      PACKAGE_NAME=$OPTARG
      shift 2
      ;;
    s)
      SOURCE_DIR=$OPTARG
      shift 2
      ;;
    v)
      VARIANT=$OPTARG
      shift 2
      ;;
    p)
      MOLIOR_PROJECTSOURCES_FILE=$OPTARG
      shift 2
      ;;
    m)
      MOLIOR_SERVER=$OPTARG
      shift 2
      ;;
    a)
      APTLY_SERVER=$OPTARG
      shift 2
      ;;
    V)
      PACKAGE_VERSION=$OPTARG
      shift 2
      ;;
    o)
      OVERLAY_VERSION=$OPTARG
      shift 2
      ;;
    F)
      DEPLOYMENT_OUTPUT_FILE=$OPTARG
      shift 2
      ;;
    O)
      OVERLAY_AUTO=1
      shift 1
      ;;
    A)
      APTLY_OVERRIDE=1
      shift 1
      ;;
    l)
      LIST_ONLY=1
      shift 1
      ;;
    c)
      ask_cleanup=0
      shift 1
      ;;
    f)
      deploy_all=1
      shift 1
      ;;
    d)
      debug_mode=1
      APT_DEBUG_OPTIONS="-o Debug::pkgProblemResolver=yes"
      shift 1
      ;;
    L)
      keep_log=1
      shift 1
      ;;
    U)
      unstable_sources=1
      shift 1
      ;;
    u)
      dist=unstable
      shift 1
      ;;
    t)
      no_color=1
      shift 1
      ;;
    r)
      KEEP_ROOTFS=1
      shift 1
      ;;
    i)
      BASE_ROOTFS=$OPTARG
      shift 2
      ;;
    S)
      src_pkg_only=1
      shift 1
      ;;
    D)
      output_build_vars=1
      shift 1
      ;;
    C)
      omit_local_suffix=1
      shift 1
      ;;
    T)
      MOLIOR_TMPDIR=$OPTARG
      shift 2
      ;;
    \?)
      exit 1
      ;;
    :)
      usage "Option -$OPTARG requires an argument." >&2
      ;;
  esac
done

if [ $LIST_ONLY -eq 0 -a `id -u` -ne 0 ]; then
  usage "Please run $0 as root" >&2
fi

PROJECT=$1
VERSION=$2

if [ -z "$PROJECT" ]; then
  usage
fi

if [ -z "$VERSION" ]; then
  usage
fi

if [ $LIST_ONLY -eq 0 -a "$deploy_all" -eq 1 ]; then
  opts=`echo $origopts | sed -e "s/$PROJECT//" -e "s/$VERSION//" -e 's/-f//'`
  for variant in `eval molior-deploy $opts -l $PROJECT $VERSION`
  do
    echo
    echo "### running molior-deploy $opts -c -v $variant $PROJECT $VERSION"
    echo
    eval molior-deploy $opts -c -v $variant $PROJECT $VERSION
  done
  exit 0
fi

if [ -z "$PACKAGE_NAME" ]; then
  PACKAGE_NAME=`echo $PROJECT | tr '[:upper:]' '[:lower:]'`
fi

if [ -z "$MOLIOR_SERVER" ]; then
  MOLIOR_SERVER=$MOLIOR_URL
fi

if [ -z "$APTLY_SERVER" ]; then
  APTLY_SERVER=$MOLIOR_REPO_URL
fi

if [ -z "$MOLIOR_TMPDIR" ]; then
  MOLIOR_TMPDIR=/tmp
fi

# clean env
unset LANGUAGE
unset LC_ALL
unset LC_PAPER
unset LC_NUMERIC
unset LC_IDENTIFICATION
unset LC_MEASUREMENT
unset LC_NAME
unset LC_TELEPHONE
unset LC_ADDRESS
unset LC_MONETARY
unset LC_TIME
unset LANG
export HOME=/root

# default settings
DEPLOYMENT_TYPE=image
INSTALL_PACKAGE=""
PRESEED_FILE=""
REQUIRED_MOLIORTOOLS_VERSION=""
if [ "$KEEP_ROOTFS" != "1" ]; then
    KEEP_ROOTFS=0
fi

# logging
if [ $no_color -ne 1 ]; then
  color_info="\e[36m\e[1m"
  color_notice="\e[34m\e[1m"
  color_warn="\e[35m\e[1m"
  color_error="\e[31m\e[1m"
  color_ask="\e[33m\e[1m"
  color_reset="\e[0m"
else
  color_info=""
  color_notice=""
  color_warn=""
  color_error=""
  color_ask=""
  color_reset=""
fi

log()
{
  if [ "$LIST_ONLY" -eq 0 ]; then
    echo " * $@"
  fi
}

log_info()
{
  if [ "$LIST_ONLY" -eq 0 ]; then
    /bin/echo -e "${color_info}I: $@ $color_reset"
  fi
}

log_notice()
{
  if [ "$LIST_ONLY" -eq 0 ]; then
    /bin/echo -e "${color_notice}N: $@ $color_reset"
  fi
}

log_warn()
{
  if [ "$LIST_ONLY" -eq 0 ]; then
    /bin/echo -e "${color_warn}W: $@ $color_reset"
  fi
}

log_error()
{
  /bin/echo -e "${color_error}E: $@ $color_reset"
  set +x
  if [ -n "$target" -a "$user_abort" -eq 0 -a "$ask_cleanup" -eq 1 ]; then
    log_info "examine situation: sudo chroot $target"
  fi

  # if RET is set to non zero, use it as exit code
  if [ -n "$RET" ]; then
      if [ "$RET" = "0" ]; then
          RET=1
      fi
  else
      RET=1
  fi
  exit $RET
}

# include helper functions
. /usr/lib/molior-deploy/molior-deploy.sh.inc
if ls /usr/lib/molior-deploy/molior-deploy.d/*.inc > /dev/null 2>&1; then
    . /usr/lib/molior-deploy/molior-deploy.d/*.inc
fi

# init
success=0
CUR_DIR=`pwd`

WORK_DIR=`mktemp -p $MOLIOR_TMPDIR -d molior-XXXXXXXX`
exit_on_error "Error creating temporary directory in '$MOLIOR_TMPDIR'"
chmod 755 $WORK_DIR
errlog=$WORK_DIR/output.log

do_fstab=1
do_compress=1
do_installation=1
do_software_installation=1
starttime="0"
endtime="0"
target=""

# binftms to be disabled
BADFMTS="cli jar jarwrapper python2.7 python3.5"

if [ "$debug_mode" -ne 1 -a "$LIST_ONLY" -ne 1 ]; then
  exec 3>&2
  exec 2>$errlog
fi

echo >&2
echo "                 _ _                     _            _             " >&2
echo " _ __ ___   ___ | (_) ___  _ __       __| | ___ _ __ | | ___  _   _ " >&2
echo "| '_ \` _ \ / _ \| | |/ _ \| '__|____ / _\` |/ _ \\ '_ \| |/ _ \| | | |" >&2
echo "| | | | | | (_) | | | (_) | | |_____| (_| |  __/ |_) | | (_) | |_| |" >&2
echo "|_| |_| |_|\___/|_|_|\___/|_|        \__,_|\___| .__/|_|\___/ \__, |" >&2
echo "                                               |_|            |___/ " >&2
echo >&2

echo $0 $@ >&2
echo "molior-tools version: $MOLIOR_TOOLS_VERSION" >&2
echo >&2

if [ "$LIST_ONLY" -eq 1 ]; then
  ask_cleanup=0
else
  set -x
fi

# functions
apt_get_chroot_with_retry ()
{
    for i in seq 1 3; do
        if chroot $target apt-get --download-only "$@"; then
            break
        fi
    done
    DEBIAN_FRONTEND=noninteractive chroot $target apt-get "$@"
}

finish ()
{
  set +x
  endtime=$(date +"%s")
  if [ "$ask_cleanup" -eq 1 ]; then
    if [ "$success" -ne 1 ]; then
      ask "Cleanup $WORK_DIR ?" Y
      if [ $? -ne 0 ]; then
        echo "Please rm -rf $WORK_DIR later ..."
        return 1
      fi
    fi
  fi
  if [ "$LIST_ONLY" -ne 1 ]; then
    log "cleanup"
  fi

  umount_bootstrap
  umount_fs

  if type deinit_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    deinit_deployment_$DEPLOYMENT_TYPE
  fi

  if [ -n "$LVM_VG" ]; then
    vgremove -f ${LVM_VG} >&2
    if vgs ${LVM_VG}_molior_renamed >/dev/null 2>&1; then
      log_warn "Warning: restoring local LVM VG $LVM_VG"
      vgrename -A y ${LVM_VG}_molior_renamed $LVM_VG >&2
      if [ $? -ne 0 ]; then
        # no errors in trap handler
        log_warn "Error restoring LVM VG $LVM_VG"
      fi
    fi
    LVM_VG=""
  fi

  if [ -n "$disk" ]; then
    # FIXME: only for loop disks, not /dev/nbd0
    losetup -d $disk
    disk=""
  fi

  if [ "$success" -eq 1 -a "$output_build_vars" -eq 1 ]; then
    get_deploy_config > $CUR_DIR/deployment.vars
    if [ -n "$SUDO_UID" -a -n "$SUDO_GID" ]; then
      chown $SUDO_UID:$SUDO_GID $CUR_DIR/deployment.vars
    fi
    log "saving deploy configuration to deployment.vars"
  fi

  set +x
  exec 2>&3 3>&-

  if which update-binfmts >/dev/null 2>&1; then
    for b in $BADFMTS
    do
      update-binfmts --enable $b >/dev/null 2>&1
    done
  fi

  if [ "$user_abort" -eq 0 ]; then
    if [ "$success" -ne 1 -o "$keep_log" -eq 1 ]; then
      if [ -z "$VARIANT" ]; then
          VARIANT="undefined"
      fi
      logfile=`date "+${PROJECT}_${VERSION}_${VARIANT}_%Y%m%d%H%M%S.log"`
      cp $errlog $CUR_DIR/$logfile
      test "$success" -ne 1 && log_info "full log: $logfile"
    fi
  fi

  if grep -q $WORK_DIR /proc/mounts; then
      umount `grep $WORK_DIR /proc/mounts | cut -d' ' -f2 | sort -r`
  fi

  if ! grep -q $WORK_DIR /proc/mounts; then
      rm -rf $WORK_DIR
  else
      log_warn "not removing $WORK_DIR, still mounted:"
      grep $WORK_DIR /proc/mounts
  fi

  diff=$((endtime-starttime))
  if [ "$success" -ne 1 ]; then
    if [ "$user_abort" -eq 0 ]; then
      log_warn "failed within $((diff / 60)) minutes and $((diff % 60)) seconds"
    fi
    return 1
  fi
  if [ -n "$deployment" ]; then
      size=`ls -lh $CUR_DIR/$deployment | cut -d ' ' -f5`
      log_notice "Deployment created in $((diff / 60))m$((diff % 60))s: $deployment ($size)"

      if type notify_deployment >/dev/null; then
        echo
        notify_deployment
        echo
      fi
  fi
  if [ $src_pkg_only -eq 1 ]; then
      log_notice "Source package downloaded: `basename $FILENAME`"
  fi
}

abort()
{
  ask_cleanup=0
  user_abort=1
  echo
  finish
}

trap finish EXIT
trap abort INT

ask()
{
  y="y"
  n="n"
  default=1
  if [ "$2" = "Y" ]; then
    default=0
    y="Y"
  fi
  if [ "$2" = "N" ]; then
    n="N"
  fi
  /bin/echo -n -e "${color_ask}Q: $1 [$y/$n] $color_reset"
  read x
  case "$x" in
    Y|y)
      return 0
      ;;
    "")
      return $default
      ;;
    *)
      return 1
      ;;
  esac
}

mountbind()
{
  mount -o bind "$1" "$2"
  if [ -n "$3" ]; then
    mount -o remount,bind,$3 $2
  fi
}

mount_bootstrap()
{
  if [ -z "$target" ]; then
    log_error "Error: \$target not set"
  fi
  CHROOTIGNORE=/usr/lib/molior-deploy/chroot-ignore
  for ignore in $CHROOTIGNORE/*
  do
    cp $ignore $target/usr/local/bin
  done

  exit_on_error "Error mounting $target/usr/local/bin"

  # Disable daemons in chroot:
  cat >> $target/usr/sbin/policy-rc.d <<EOM
#!/bin/sh
while true; do
    case "\$1" in
      -*) shift ;;
      makedev|x11-common) exit 0;;
EOM
  if [ -n "$CHROOT_DAEMONS_ENABLED" ]; then
  cat >> $target/usr/sbin/policy-rc.d <<EOM
      $CHROOT_DAEMONS_ENABLED) exit 0;;
EOM
  fi
  cat >> $target/usr/sbin/policy-rc.d <<EOM
      *) exit 101;;
    esac
done
EOM
  chmod +x $target/usr/sbin/policy-rc.d

  mount udev -t devtmpfs $target/dev
  exit_on_error "Error mounting $target/dev"
  mount devpts -t devpts $target/dev/pts
  exit_on_error "Error mounting $target/dev/pts"
  mount proc -t proc $target/proc
  exit_on_error "Error mounting $target/proc"
  mount sysfs -t sysfs $target/sys
  exit_on_error "Error mounting $target/sys"

  mkdir -p $WORK_DIR/chroottmp
  # set permissions on tmp including the sticky bit
  chmod 1777 $WORK_DIR/chroottmp
  mountbind $WORK_DIR/chroottmp $target/tmp
  exit_on_error "Error mounting $target/tmp"

  if [ -d $target/usr/tmp ]; then
    mkdir -p $WORK_DIR/chrootvartmp
    mountbind $WORK_DIR/chrootvartmp $target/var/tmp
    exit_on_error "Error mounting $target/var/tmp"
  fi
}

umount_bootstrap()
{
  if [ -z "$target" ]; then
    return
  fi
  sync

  if [ -n "$BIND_MOUNTS" ]; then
    for m in $BIND_MOUNTS
    do
      to=`echo $m | cut -d: -f2`
      unmount $target/$to
    done
  fi

  if [ -d "$target" ]; then
    CHROOTIGNORE=/usr/lib/molior-deploy/chroot-ignore
    for ignore in $CHROOTIGNORE/*
    do
      rm -f $target/usr/local/bin/$(basename "$ignore")
    done
    rm -f $target/usr/sbin/policy-rc.d

    for m in `grep $target/proc /proc/mounts | cut -d' ' -f2 | tac`
    do
      umount $m
    done
    umount $target/proc
    umount $target/sys
    umount $target/dev/pts
    umount $target/dev
    umount $target/tmp
    if [ -e $target/etc/apt/auth.conf ]; then
      umount $target/etc/apt/auth.conf
    fi
    mountpoint -q $target/var/tmp && umount $target/var/tmp
  fi
}

include_package()
{
  local package=$1
  local mode=$2  # "deploy_conf" or "file"

  if [ "$mode" = "deploy_conf" ]; then
    deploy_conf_level=$((deploy_conf_level + 1))
  else
    include_file_level=$((include_file_level + 1))
  fi

  if echo $package | grep -q ":"; then
    source_file=`echo $package | cut -d: -f2`
    package=`echo $package | cut -d: -f1`
  else
    if [ "$mode" = "file" ]; then
      log_error "include file '$package' must be in the form 'package:sourcefile'"
      exit 1
    fi
    source_file=deploy/common.inc
  fi

  log "downloading ${mode} package: $package"

  baseurls=`echo "$APT_SOURCES" | grep $SOURCEMIRROR/repos/ | awk '{print $2}'`
  for baseurl in $baseurls
  do
    SOURCES_VERSION=`basename $baseurl`
    curl -n -f -s --retry 10 -o $WORK_DIR/Sources.func $baseurl/dists/$dist/main/source/Sources
    lines=`wc -l $WORK_DIR/Sources 2>/dev/null | cut -d' ' -f1`
    if [ -n "$lines" ] && [ "$lines" -eq 0 ]; then
      continue
    fi
    srcinfo=`/usr/lib/molior-tools/find-latest-version.pl $package < $WORK_DIR/Sources.func`
    if [ $? -ne 0 ]; then
      continue
    fi
    PKG_NAME=`echo $srcinfo | cut -d ' ' -f 1`/`echo $srcinfo | cut -d ' ' -f 2`
    PKG_REV=`echo $srcinfo | cut -d ' ' -f 3`
    if [ -n "$PKG_NAME" ]; then
      FUNC_SOURCEMIRROR=$baseurl
      break
    fi
  done
  rm -f $WORK_DIR/Sources.func
  if [ -z "$PKG_NAME" ]; then
    log_error "Error finding '$package' source package in apt sources"
  fi

  pkgdir=`mktemp -d $WORK_DIR/conf-XXXXX`
  old_dir=$PWD
  cd $pkgdir
  curl -n -f -s --retry 10 -O -J $FUNC_SOURCEMIRROR/$PKG_NAME
  exit_on_error "Error downloading $FUNC_SOURCEMIRROR/$PKG_NAME"

  tar xf `basename $PKG_NAME`
  exit_on_error "Error extracting `basename $PKG_NAME`"
  rm -f `basename $PKG_NAME`

  log "sourcing from $package ($PKG_REV): $source_file"

  # provide new SOURCE_DIR for pkg includes to work (recursively)
  if [ "$mode" = "deploy_conf" ]; then
    eval orig_SOURCE_DIR_deploy_conf_$deploy_conf_level=$SOURCE_DIR
  else
    eval orig_SOURCE_DIR_file_$include_file_level=$SOURCE_DIR
  fi

  SOURCE_DIR=$pkgdir/$package

  if [ "$mode" = "deploy_conf" ]; then
    cd `dirname $package/$source_file`
    . $SOURCE_DIR/$source_file
    cd - >/dev/null
    eval SOURCE_DIR=\$orig_SOURCE_DIR_deploy_conf_$deploy_conf_level
    deploy_conf_level=$((deploy_conf_level - 1))
  else
    # Copy the file (for include_file) to the initial source directory
    eval orig_dir=\$orig_SOURCE_DIR_file_$include_file_level
    cp $SOURCE_DIR/$source_file $orig_dir/$source_file
    eval SOURCE_DIR=\$orig_SOURCE_DIR_file_$include_file_level
    include_file_level=$((include_file_level - 1))
  fi

  cd $old_dir
  rm -rf $pkgdir
}

include_deploy_conf()
{
  include_package "$1" "deploy_conf"
}

include_file()
{
  include_package "$1" "file"
}

setup_deployment()
{
  DEPLOYMENT_TIMESTAMP=`date -R`
  starttime=$(date +"%s")
  log_info "Creating deployment for $PROJECT/$VERSION"
  log "molior-tools $MOLIOR_TOOLS_VERSION"
  log "started: `date -R`"
  log "logfile: $WORK_DIR/output.log"

  if [ -z "$MOLIOR_PROJECTSOURCES_FILE" ]; then
    param=""
    if [ $unstable_sources -eq 1 ]; then
      param="?unstable=true"
    fi
    log_info "Getting deployment information ..."
    SOURCESURL=$MOLIOR_SERVER/api2/project/$PROJECT/$VERSION/aptsources
    APT_SOURCES_ORIG=`curl -n -f -s --retry 10 $SOURCESURL$param`
    if [ -z "$APT_SOURCES_ORIG" ]; then
      SOURCESURL=$MOLIOR_SERVER/api/projectsources/$PROJECT/$VERSION
      APT_SOURCES_ORIG=`curl -n -f -s --retry 10 $SOURCESURL`
      if [ -z "$APT_SOURCES_ORIG" ]; then
        log_error "Error downloading $SOURCESURL"
      fi
    fi
  else
    log_info "Reading deployment information from $MOLIOR_PROJECTSOURCES_FILE ..."
    APT_SOURCES_ORIG=`cat $MOLIOR_PROJECTSOURCES_FILE`
    if [ -z "$APT_SOURCES_ORIG" ]; then
      log_error "Error reading $MOLIOR_PROJECTSOURCES_FILE"
    fi
  fi
  if [ "$APTLY_OVERRIDE" -eq 1 ]; then
    APT_SOURCES_ORIG=`echo "$APT_SOURCES_ORIG" | sed "s=deb \([^:]\)\+://\([^/]\)\+=deb $APTLY_SERVER="`
  fi
  APT_SOURCES=`echo "$APT_SOURCES_ORIG" | sed -e '/^#/d' -e '/^$/d'`
  MIRROR=`echo "$APT_SOURCES" | head -n 1 | cut -d' ' -f 2`
  if [ -z "$MIRROR" ]; then
    log_error "No base mirror repo found"
  fi
  SUITE=`echo "$APT_SOURCES" | head -n 1 | cut -d' ' -f 3`
  if [ -z "$SUITE" ]; then
    log_error "No SUITE in APT repo found"
  fi
  tmp=`dirname $MIRROR`
  REPOURL=`dirname $tmp`
  BASEMIRROR=`basename $tmp`
  BASEVERSION=`basename $MIRROR`
  log "mirror: $MIRROR"
  SOURCEMIRROR=`echo "$APT_SOURCES" | head -n 2 | tail -n 1 | cut -d' ' -f 2`
  SOURCEMIRROR=`dirname $SOURCEMIRROR` # cut projectversion
  SOURCEMIRROR=`dirname $SOURCEMIRROR` # cut project
  SOURCEMIRROR=`dirname $SOURCEMIRROR` # cut /repos

  log_info "Getting source package ..."
  if [ -n "$SOURCE_DIR" ]; then
    SOURCE_DIR=`readlink -f $SOURCE_DIR`
    log "using local package source: $SOURCE_DIR"
    cd $SOURCE_DIR
    if [ $omit_local_suffix -eq 0 ]; then
      REVISION=`dpkg-parsechangelog -S Version`+local
    else
      REVISION=`dpkg-parsechangelog -S Version`
    fi
    log "found source package: $PACKAGE_NAME $REVISION"
    cd - >/dev/null
  else
    SOURCES_VERSION=$VERSION
    if [ -n "$OVERLAY_VERSION" ]; then
      SOURCES_VERSION=$OVERLAY_VERSION
      log "using overlay source: $SOURCES_VERSION"
    fi
    if [ "$OVERLAY_AUTO" -eq 1 ]; then
      baseurls=`echo "$APT_SOURCES" | grep $SOURCEMIRROR/repos/$PROJECT | awk '{print $2}'`
      for baseurl in $baseurls
      do
        SOURCES_VERSION=`basename $baseurl`
        log "trying to download package source from $SOURCES_VERSION"
        curl -n -f -s --retry 10 -o $WORK_DIR/Sources $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources
        if [ `wc -l $WORK_DIR/Sources 2>/dev/null | cut -d' ' -f1` -eq 0 ]; then
          # try next baseurl
          continue
        fi
        srcinfo=`/usr/lib/molior-tools/find-latest-version.pl $PACKAGE_NAME $PACKAGE_VERSION < $WORK_DIR/Sources`
        if [ $? -ne 0 ]; then
          # try next baseurl
          continue
        fi
        FILENAME=`echo $srcinfo | cut -d ' ' -f 1`/`echo $srcinfo | cut -d ' ' -f 2`
        REVISION=`echo $srcinfo | cut -d ' ' -f 3`
        if [ -n "$FILENAME" ]; then
          # found package
          break
        fi
      done
      if [ -z "$FILENAME" ]; then
        log_error "No filename found for $PACKAGE_NAME in $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources"
      fi
      log "using package source: $SOURCES_VERSION"
    else
      curl -n -f -s --retry 10 -o $WORK_DIR/Sources $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources
      # FIXME: check if exists...
      if [ `wc -l $WORK_DIR/Sources 2>/dev/null | cut -d' ' -f1` -eq 0 ]; then
        log_error "Could not download $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources"
      fi
      srcinfo=`/usr/lib/molior-tools/find-latest-version.pl $PACKAGE_NAME $PACKAGE_VERSION < $WORK_DIR/Sources`
      exit_on_error "Error: package $PACKAGE_NAME not found in $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources"

      FILENAME=`echo $srcinfo | cut -d ' ' -f 1`/`echo $srcinfo | cut -d ' ' -f 2`
      REVISION=`echo $srcinfo | cut -d ' ' -f 3`
      if [ -z "$FILENAME" ]; then
        log_error "No filename found for $PACKAGE_NAME in $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/dists/$dist/main/source/Sources"
      fi
    fi

    log "downloading source: $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/$FILENAME"
    cd $WORK_DIR
    curl -n -f -s --retry 10 -O -J $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/$FILENAME
    exit_on_error "Error downloading $SOURCEMIRROR/repos/$PROJECT/$SOURCES_VERSION/$FILENAME"

    if [ $src_pkg_only -eq 1 ]; then
      mv `basename $FILENAME` $CUR_DIR
      if [ -n "$SUDO_UID" -a -n "$SUDO_GID" ]; then
        chown $SUDO_UID:$SUDO_GID $CUR_DIR/`basename $FILENAME`
      fi
      success=1
      exit
    fi

    tar xf `basename $FILENAME`
    rm -f `basename $FILENAME`
    cd - >/dev/null
    SOURCE_DIR=$WORK_DIR/$PACKAGE_NAME
  fi

  if [ ! -d $SOURCE_DIR/deploy ]; then
    log_error "No deploy/ directory found in $SOURCE_DIR"
  fi

  if [ -z "`ls -1 $SOURCE_DIR/deploy/*.conf 2>/dev/null`" ]; then
      log_error "No deploy/*.conf files found in $SOURCE_DIR"
  fi

  VARIANT=`echo $VARIANT | sed s/\.conf$//`
  variants=""
  count=0
  found_variant=0
  for t in $SOURCE_DIR/deploy/*.conf
  do
    if [ ! -z "$variants" ]; then
      variants="$variants "
    fi
    t=`basename $t | sed s/\.conf$//`
    variants="$variants$t"
    if [ -n "$VARIANT" ]; then
      if [ "$t" = "$VARIANT" ]; then
        found_variant=1
        break
      fi
    fi
    count=$((count + 1))
  done
  if [ -n "$VARIANT" -a "$found_variant" -ne 1 ]; then
    ask_cleanup=0
    user_abort=1
    log_error "Specified deployment variant '$VARIANT' not found (missing deploy/$VARIANT.conf)"
  fi
  if [ "$count" -eq 1 -a "$found_variant" -ne 1 ]; then
    found_variant=1
    VARIANT=$variants
  fi

  if [ "$LIST_ONLY" -eq 1 ]; then
    for v in `echo $variants`
    do
      echo $v
    done
    success=1
    exit 0
  fi

  if [ "$found_variant" -ne 1 ]; then
    while true
    do

      # Read deployment variant. Use tab-completion if available.
      if type rlwrap > /dev/null; then
        rlwrap_comp=$WORK_DIR/molior-deployments.list
        echo $variants > $rlwrap_comp
        VARIANT=$(rlwrap -S "Q: Please choose a deployment variant: " -pYellow -e '' -i --break-chars ' ' -f $rlwrap_comp -o cat)
        rm -f $rlwrap_comp
      else
        /bin/echo -n -e "${color_ask}Q: Please choose a deployment variant:\n`echo $variants | tr ' ' '\n' | sed 's/^/ > /'`\nEnter variant: $color_reset"
        read VARIANT
      fi

      if [ -z "$VARIANT" ]; then
        log_warn "No deployment variant choosen, aborting ..."
        ask_cleanup=0
        user_abort=1
        VARIANT="undefined"
        exit 1
      fi
      if [ -f $SOURCE_DIR/deploy/$VARIANT.conf ]; then
        starttime=$(date +"%s")
        break
      fi
    done
  fi
  log_notice "Selected deployment variant/type: $VARIANT/$DEPLOYMENT_TYPE"
  cd `dirname $SOURCE_DIR/deploy/$VARIANT.conf`
  . $SOURCE_DIR/deploy/$VARIANT.conf
  cd - >/dev/null

  check_required_version

  # load plugin
  if [ ! -e /usr/lib/molior-deploy/plugins/$DEPLOYMENT_TYPE.plugin ]; then
    log "using custom plugin for '$DEPLOYMENT_TYPE'"
  else
    . /usr/lib/molior-deploy/plugins/$DEPLOYMENT_TYPE.plugin
  fi

  if [ -n "$ROOTPART" ]; then
    log_warn "Warning: ROOTPART is deprecated, please use PART${ROOTPART}_MNT=/"
    eval PART${ROOTPART}_MNT=/
  fi

  if [ -z "$ARCH" ]; then
    log_warn "The deployment does not specify an architecture, assuming ARCH=amd64"
    ARCH=amd64
  fi

  if echo $ARCH | grep -q arm; then
    if ! which /usr/bin/qemu-arm-static >/dev/null || ! which /usr/sbin/update-binfmts >/dev/null; then
      log_error "Error: qemu arm support is missing, run apt-get install binfmt-support qemu-user-static"
    fi
  fi

  if [ -z "$DEPLOYMENT_COMPRESSION" ]; then
      DEPLOYMENT_COMPRESSION=xz
  fi
  case $DEPLOYMENT_COMPRESSION in
      none)
          DEPLOYMENT_COMPRESSION_EXT=""
      ;;
      xz)
          DEPLOYMENT_COMPRESSION_EXT=".xz"
      ;;
      gz|gzip)
          DEPLOYMENT_COMPRESSION_EXT=".gz"
      ;;
      *)
          log_error "Unsupported deployment compression: '$DEPLOYMENT_COMPRESSION' (use: none, gz, xz)"
      ;;
  esac

  if [ -n "$RAID_NAME" -a -z "$RAID_DEVICES" ]; then
    log_error "Error: RAID devices not definded, please set \$RAID_DEVICES"
  fi

  if [ -z "$DEPLOYMENT_OUTPUT_FILE" ]; then
    DEPLOYMENT_OUTPUT_FILE="${PROJECT}_${VERSION}_${REVISION}_$VARIANT"
  fi

  target=$WORK_DIR/root
  mkdir $target
}

bootstrap_deployment()
{
  KEY_URL=$REPOURL/$PUBKEY_FILE
  log "importing gpg key from $KEY_URL"

  include="gnupg"
  eval t=\$DEBOOTSTRAP_INCLUDE_`echo $SUITE | tr '-' '_'`
  if [ -n "$t" ]; then
    include="$include,$t"
  fi

  i=0
  for url in $KEY_URL $APT_KEYS_EXTRA
  do
    if [ -z "$url" ]; then
      continue
    fi
    if [ $i -ne 0 ]; then
      postfix=".$i"
    else
      postfix=""
    fi
    i=$((i + 1))
    curl -L -n -f -s --retry 10 -o $WORK_DIR/repo.asc$postfix $url
    exit_on_error "Error downloading $url"
  done
  gpg -q --import --no-default-keyring --keyring=trustedkeys.gpg $WORK_DIR/repo.asc

  log "downloading debootstrap for $SUITE $BASEMIRROR/$BASEVERSION $ARCH"
  curl -n -f -s --retry 10 -o $WORK_DIR/root.tar.xz $MOLIOR_SERVER/debootstrap/${BASEMIRROR}_${BASEVERSION}_$ARCH.tar.xz
  if [ $? -eq 0 ]; then
    log "extracting debootstrap"
    mkdir -p $target
    cd $target
    tar $TAR_PXZ -xf $WORK_DIR/root.tar.xz
    cd - >/dev/null
    rm -f $WORK_DIR/root.tar.xz
    cp -fL /etc/resolv.conf $target/etc/resolv.conf
  else
    log "error downloading debootstrap archive..."
    log "running debootstrap for $SUITE $BASEMIRROR/$BASEVERSION $ARCH"

    if echo $ARCH | grep -q arm; then
      debootstrap --foreign --arch $ARCH --keyring=/root/.gnupg/trustedkeys.gpg --variant=minbase --include=$include $SUITE $target $MIRROR >&2
      exit_on_error "debootstrap failed"
      if [ "$ARCH" = "armhf" ]; then
        cp /usr/bin/qemu-arm-static $target/usr/bin/
      else
        cp /usr/bin/qemu-aarch64-static $target/usr/bin/
      fi
      chroot $target /debootstrap/debootstrap --second-stage --no-check-gpg >&2
      exit_on_error "debootstrap failed"
    else
      debootstrap --arch $ARCH --keyring=/root/.gnupg/trustedkeys.gpg --variant=minbase --include=$include $SUITE $target $MIRROR >&2
      exit_on_error "debootstrap failed"
    fi

    if chroot $target dpkg -s tzdata > /dev/null 2>&1; then
      # The package tzdata cannot be --excluded in debootstrap, so remove it here
      # In order to use debconf for configuring the timezone, the tzdata package
      # needs to be installer later as a dependency, i.e. after the config package
      # preseeding debconf.
      chroot $target apt-get purge --yes tzdata >&2
      rm -f $target/etc/timezone
    fi

    chroot $target apt-get clean >&2
  fi

  if [ -n "$MINIMIZE" ]; then
    if [ "$MINIMIZE" -eq 1 ]; then

      cat >> $target/etc/dpkg/dpkg.cfg.d/excludes <<EOF
path-exclude=/usr/share/locale/*
path-include=/usr/share/locale/locale.alias
path-exclude=/usr/share/man/*
path-exclude=/usr/share/doc/*
path-exclude=/usr/share/info/*
path-exclude=/usr/share/common-licenses/*
EOF
      # Clean up already existing locales and docs
      if [ -e $target/usr/share/locale/locale.alias ]; then
        mv $target/usr/share/locale/locale.alias $WORK_DIR
      fi

      rm -rf $target/usr/share/locale/* \
             $target/usr/share/man/* \
             $target/usr/share/doc/* \
             $target/usr/share/info/* \
             $target/usr/share/common-licenses/*

      # Recreate the empty man directories at least jre-headless depends on
      # man1 being available
      man_index=0
      while [ $man_index -le 9 ]; do
        mkdir -p $target/usr/share/man/man$man_index
        man_index=$(( man_index + 1 ))
      done

      if [ -e $WORK_DIR/locale.alias ]; then
        mv $WORK_DIR/locale.alias $target/usr/share/locale/
      fi
    fi
  fi

  if [ -z "$TARGET_HOSTNAME" ]; then
    TARGET_HOSTNAME=$PROJECT-$VARIANT
  fi
  echo "$TARGET_HOSTNAME" > $target/etc/hostname
  cat >$target/etc/hosts <<EOF
127.0.0.1       localhost

EOF
  echo "127.0.1.1 $TARGET_HOSTNAME" >> $target/etc/hosts

  echo "$APT_SOURCES_ORIG" > $target/etc/apt/sources.list
  if [ -n "$APT_SOURCES_EXTRA" ]; then
    echo "$APT_SOURCES_EXTRA" > $target/etc/apt/sources.list.d/extra.list
  fi

  if [ $do_fstab -eq 1 ]; then
    create_fstab
  fi

  cat $WORK_DIR/repo.asc* | gpg --dearmor -o $target/etc/apt/trusted.gpg.d/molior.gpg
  exit_on_error "Error adding apt key"

  echo "using nameservers:" >&2
  cat $target/etc/resolv.conf >&2

  # allow accessing password protected apt repos inside chroot
  if [ -e "$HOME/.netrc" ]; then
    # do not leave traces of the credentials on the target
    cp $HOME/.netrc $WORK_DIR/
    touch $target/etc/apt/auth.conf
    # not mounting read-only, debootstrap will run chown
    mountbind $WORK_DIR/.netrc $target/etc/apt/auth.conf
  fi

  if [ -n "$DPKG_ADD_ARCH" ]; then
    log "adding $DPKG_ADD_ARCH architecture"
    chroot $target dpkg --add-architecture $DPKG_ADD_ARCH
  fi

  log "updating APT database"
  chroot $target apt-get -o Acquire::Languages=none update >&2
  exit_on_error "apt-get update failed"

  log "upgrading system"
  apt_get_chroot_with_retry --yes dist-upgrade >&2
  exit_on_error "apt-get dist-upgrade failed"

  if [ -n "$BIND_MOUNTS" ]; then
    for m in $BIND_MOUNTS
    do
      from=`echo $m | cut -d: -f1`
      to=`echo $m | cut -d: -f2`
      opts=`echo $m | cut -d: -f3`
      if [ -z "$opts" ]; then
        opts="rw,noexec,nosuid,nodev"
      fi
      mkdir -p $target/$from $target/$to
      mount -o $opts,bind $target/$from $target/$to
    done
  fi
}

install_deployment()
{
  if [ -z "$target" ]; then
    log_error "Error: \$target not set"
  fi
  mount_bootstrap

  if [ -n "$PRESEED_FILE" ]; then
    log "applying preseed file '$PRESEED_FILE'"
    if [ -f "$SOURCE_DIR/$PRESEED_FILE" ]; then
      chroot $target debconf-set-selections < $SOURCE_DIR/$PRESEED_FILE
      exit_on_error "Error applying preseed file '$PRESEED_FILE'"
    else
      log_error "The preseed file '$PRESEED_FILE' does not exist in source package"
    fi
  fi

  log "installing: $INSTALL_PACKAGE"
  if [ -t 1 ]; then
      (install_progress) &
      progress_pid=$!
  fi
  apt_get_chroot_with_retry install $APT_DEBUG_OPTIONS --no-install-recommends --yes $INSTALL_PACKAGE $APT_INSTALL_EXTRA >&2
  ret=$?
  if [ -t 1 ]; then
      rm -f $WORK_DIR/.show_install_progress
      wait $progress_pid
  fi
  if [ $ret -ne 0 ]; then
    log_error "Error installing software"
  fi

  chroot $target apt-get clean >&2
  chroot $target dpkg -l | tail -n +6 | awk '{ printf "%-42s %s\n", $2, $3 }' >$WORK_DIR/packages.txt
}

install_progress()
{
    set +x
    total=""
    already=`grep "^Get:\|^Preparing to unpack\|^Setting up" $errlog -c`
    touch $WORK_DIR/.show_install_progress
    sleep 10
    while [ -f $WORK_DIR/.show_install_progress ]; do
        sleep 2
        if [ -z "$total" ]; then
            total=`grep "newly installed" $errlog | tail -n1 | sed 's/.*, \([0-9]\+\) newly installed.*/\1/'`
            total=$((total * 3))
        fi
        if [ -z "$total" ]; then
            continue
        fi
        current=`grep "^Get:\|^Preparing to unpack\|^Setting up" $errlog -c`
        current=$((current - already))
        /bin/echo -ne "\r   `perl -e "print '.' x $current" | pv -pf --width 32 -s $total 2>&1 >/dev/null`"
    done
    /bin/echo -ne "                                        \r"
}

cleanup_deployment()
{
  if [ -z "$target" ]; then
    log_error "Error: \$target not set"
  fi
  if [ "$ARCH" = "armhf" ]; then
    rm -f $target/usr/bin/qemu-arm-static
  elif [ "$ARCH" = "arm64" ]; then
    rm -f $target/usr/bin/qemu-aarch64-static
  fi
  rm -f $target/etc/ssh/ssh_host_*
  if [ -d $target/etc ] && [ -x $target/bin/systemd ]; then
    echo -n > $target/etc/machine-id
  fi
  rm -f $target/var/lib/dbus/machine-id

  rm -f $target/var/lib/apt/lists/*Packages* $target/var/lib/apt/lists/*Release*
  rm -f $target/var/log/alternatives.log $target/var/log/bootstrap.log \
        $target/var/log/dpkg.log $target/var/log/faillog $target/var/log/lastlog \
        $target/var/log/apt/*
}

get_deployment_filename()
{
  EXTENSION="$1"

  deployment="$DEPLOYMENT_OUTPUT_FILE"
  if [ -n "$EXTENSION" ]; then
    deployment="$deployment.$EXTENSION"
  fi
  echo "$deployment"
}

# directory deployments are used from multiple plugins
init_deployment_dir()
{
  do_fstab=0
  target=$WORK_DIR/root
  mkdir -p $target
  log "rootfs: $target"
}

# Try to kill pid=$1 nretries=$2 times
kill_with_retry()
{
    pid=$1
    nretries=$2
    # Nothing to kill
    if ! ps -p $pid > /dev/null 2>&1; then
        log "pid=$pid not found"
        return
    fi
    if [ -z "$nretries" ] || [ "$nretries" -lt 0 ]; then
        nretries=0
    fi
    kill $pid
    retval=$?
    if [ "$retval" -ne 0 ]; then
        if [ "$nretries" -gt 0 ]; then
            log_warn "Retrying to kill $pid, $nretries more attempts"
            sleep 1  # Sleep a bit before retrying
            kill_with_retry $pid $((nretries - 1))
            retval=$?
        else
            log_warn "Failed to kill $pid, no more attempts"
        fi
    fi
    return $retval
}

install_docker()
{
    if [ -z "$DOCKER_COMPOSE_FILE" ] && [ -z "$DOCKER_CONTAINERS" ]; then
        return  # nothing to do
    fi

    umount_bootstrap

    install_docker_start  # after this, not exit / log_error is allowed until install_docker_stop is called
    install_docker_pull
    ret=$?
    if [ "$ret" -eq 0 ]; then
      install_docker_postinst_hooks
    fi
    install_docker_stop
    if [ "$ret" -ne 0 ]; then
        log_error "Error downloading docker containers"
    fi

    # restore bootstrap mounts
    mount_bootstrap
}

install_docker_start()
{
  # prepare filesystem
  docker_root_remount=0
  if ! mountpoint -q $target; then
    docker_root_remount=1
    mount -o bind $target $target
  fi

  mount udev -t devtmpfs $target/dev
  exit_on_error "Error mounting $target/dev"
  mount devpts -t devpts $target/dev/pts
  mount proc -t proc $target/proc
  exit_on_error "Error mouting /proc rw"
  mount sys -t sysfs $target/sys
  exit_on_error "Error mouting /sys rw"
  mkdir -p $target/run/systemd/journal
  mount --bind /run/systemd/journal $target/run/systemd/journal
  exit_on_error "Error mounting /run/systemd/journal"
  chroot $target cgroupfs-mount >&2
  exit_on_error "Error mounting cgroup"

  # prepare docker compose env dir
  mkdir $target/tmp/docker-compose
  if [ -n "$DOCKER_COMPOSE_ENV_FILE" -a -e $target/$DOCKER_COMPOSE_ENV_FILE ]; then
    cp $target/$DOCKER_COMPOSE_ENV_FILE $target/tmp/docker-compose/.env
  fi

  if chroot $target dpkg -s podman-docker >/dev/null 2>&1; then
    log "using podman-docker wrapper"
  else
    # start docker
    chroot $target sh -c '. /etc/default/docker; TZ=UTC exec dockerd --iptables=false -H unix:// $DOCKER_OPTS' >&2 &
    dockerpid=$!
    sleep 5  # Give it time to start and maybe crash
    if ! kill -0 "$dockerpid"; then
      log_error "Error starting dockerd"
    fi
  fi
}

install_docker_pull()
{
  # in this function exit / log_error is not allowed, need to tear down chroot docker daemon first
  ret=0
  if [ -z "$DOCKER_COMPOSE_FILE" ] && [ -z "$DOCKER_CONTAINERS" ]; then
    log_warn "No docker containers or compose file specified."
    ret=1
    return $ret
  fi

  if [ -z "$DOCKER_CONTAINERS" ]; then
    docker_containers=`grep -v -P '^[ \t]*#' $target/$DOCKER_COMPOSE_FILE | grep "image:" | awk '{ print $2 }' | LC_ALL=C sort | uniq`
    if [ -z "$docker_containers" ]; then
      log_warn "Cannot find images in DOCKER_COMPOSE_FILE $target/$DOCKER_COMPOSE_FILE"
      ret=1
      return $ret
    fi
  fi

  if [ -z "$docker_containers" ] && [ -n "$DOCKER_CONTAINERS" ]; then
    docker_containers=`echo "$DOCKER_CONTAINERS" | sed '/^$/d'`
  fi

  if [ -z "$docker_containers" ]; then
    log_warn "Cannot find docker containers to pull"
    ret=1
    return $ret
  fi

  # pull containers
  total_docker_images=`echo "$docker_containers" | wc -l`
  i=1
  for container in $docker_containers
  do
    if echo "$container" | grep -q "^#"; then
      continue
    fi
    if echo "$container" | grep -q "^[\t ]*$"; then
      continue
    fi
    if [ -f $target/tmp/docker-compose/.env ]; then
        container=`. $target/tmp/docker-compose/.env; eval echo $container`
    fi
    if [ -n "$MOLIOR_DOCKER_LOGIN_USER" -a -n "$MOLIOR_DOCKER_LOGIN_TOKEN" ] || [ -n "$MOLIOR_DOCKER_LOGINS" ]; then
        docker_registry=""
        docker_user=""
        docker_pass=""
        if [ -n "$MOLIOR_DOCKER_LOGINS" ]; then
            for docker_login in $MOLIOR_DOCKER_LOGINS
            do
                test -z "$docker_login" && continue
                docker_registry=`echo $docker_login | cut -d@ -f2`

                if echo "$container" | grep -q "^$docker_registry"; then
                    l=`echo $docker_login | cut -d@ -f1`
                    docker_user=`echo $l | cut -d: -f1`
                    docker_pass=`echo $l | cut -d: -f2`
                    break
                fi
            done
        elif echo $MOLIOR_DOCKER_LOGIN_USER | grep -q "@"; then
            docker_registry=`echo $MOLIOR_DOCKER_LOGIN_USER | cut -d@ -f2`
            docker_user=`echo $MOLIOR_DOCKER_LOGIN_USER | cut -d@ -f1`
            docker_pass=$MOLIOR_DOCKER_LOGIN_TOKEN
        else
            docker_registry=`echo $container | cut -d: -f1`
            docker_user=$MOLIOR_DOCKER_LOGIN_USER
            docker_pass=$MOLIOR_DOCKER_LOGIN_TOKEN
        fi
        if [ -n "$docker_user" ]; then
            if ! echo $docker_login_registries | grep -w -q $docker_registry; then
                log "docker login '$docker_registry'"
                echo chroot $target sh -c "docker login $docker_registry -u $docker_user -p ****" >&2
                set +x
                echo $docker_pass | chroot $target sh -c "docker login $docker_registry -u $docker_user --password-stdin" >&2
                ret=$?
                set -x
                if [ "$ret" -ne 0 ]; then
                    log_warn "Error docker login $docker_registry"
                    return $ret
                fi
                docker_login_registries="$docker_login_registries $docker_registry"
            fi
        fi
    fi
    l=$(($(echo -n $total_docker_images | wc -c) - $(echo -n $i | wc -c)))
    p=$(perl -e "print ' ' x $l")
    log "docker pull $p$i/$total_docker_images: $container"
    chroot $target sh -c "docker pull $container" >&2
    ret=$?
    if [ "$ret" -ne 0 ]; then
        log_warn "Error pulling docker containers"
        return $ret
    fi
    i=$((i + 1))
  done

  return $ret
}

install_docker_postinst_hooks()
{
  if type postinst_docker >/dev/null; then
      postinst_docker
  elif type postinst_docker_$DEPLOYMENT_TYPE >/dev/null; then
      postinst_docker_$DEPLOYMENT_TYPE
  fi
}

install_docker_stop()
{
  rm -rf $target/tmp/docker-compose

  # stop docker
  if [ -n "$dockerpid" ]; then
    kill_with_retry $dockerpid 3
    exit_on_error "kill dockerpid=$dockerpid unsuccessful"
  fi

  # wait for dockerd do terminate
  sleep 5

  # cleaup filesystems
  umount $target/run/systemd/journal
  exit_on_error "Error unmounting $target/run/systemd/journal"
  chroot $target cgroupfs-umount >&2
  exit_on_error "Error unmounting cgroupfs"
  umount $target/sys/fs/cgroup
  exit_on_error "Error unmounting $target/sys/fs/cgroup"
  umount $target/sys
  exit_on_error "Error unmounting $target/sys"
  umount $target/proc
  exit_on_error "Error unmounting $target/proc"
  umount $target/dev/pts
  exit_on_error "Error unmounting $target/dev/pts"
  umount $target/dev
  exit_on_error "Error unmounting $target/dev"
  if [ $docker_root_remount -eq 1 ]; then
    docker_root_remount=0
    umount $target
    exit_on_error "error unmounting docker remount"
  fi

  # remove any docker credentials
  rm -f $target/root/.docker/config.json
}

check_required_version()
{
    if [ "$REQUIRED_MOLIORTOOLS_VERSION" != "" ]; then
        log "checking required molior-tools version"
        dpkg --compare-versions $MOLIOR_TOOLS_VERSION $REQUIRED_MOLIORTOOLS_VERSION
        exit_on_error "Incompatible version. Required version: $REQUIRED_MOLIORTOOLS_VERSION"
    fi
}

run_postinst()
{
    # enable DNS in chroot for postinst
    if [ -e $target/etc/resolv.conf -o -h $target/etc/resolv.conf ]; then
      mv $target/etc/resolv.conf $target/etc/resolv.conf.molior-deploy.bak
    fi
    cp -L /etc/resolv.conf $target/etc/resolv.conf

    # run postinst_deployment
    if type postinst_deployment >/dev/null; then
      postinst_deployment
    elif type postinst_deployment_$DEPLOYMENT_TYPE >/dev/null; then
      postinst_deployment_$DEPLOYMENT_TYPE
    fi

    # ensure DNS is still enabled
    rm -f $target/etc/resolv.conf
    cp -L /etc/resolv.conf $target/etc/resolv.conf

    # install docker containers
    if [ -n "`echo "$DOCKER_CONTAINERS" | sed '/^$/d'`" -o -n "$DOCKER_COMPOSE_FILE" ]; then
      log_info "Installing docker containers ..."
      install_docker
    fi

    # run postinst_internal_deployment
    if type postinst_internal_deployment_$DEPLOYMENT_TYPE >/dev/null; then
      postinst_internal_deployment_$DEPLOYMENT_TYPE
    fi

    # restore resolv.conf
    rm -f $target/etc/resolv.conf
    if [ -e $target/etc/resolv.conf.molior-deploy.bak -o -h $target/etc/resolv.conf.molior-deploy.bak ]; then
      mv $target/etc/resolv.conf.molior-deploy.bak $target/etc/resolv.conf
    fi
}

# 1st stage: create the base rootfs
workflow_base()
{
  # disable conflicting binfmts
  if which update-binfmts >/dev/null 2>&1; then
    for b in $BADFMTS
    do
      update-binfmts --disable $b >&2
    done
  fi

  setup_deployment

  # check host system for pre conditions (i.e. postgres not running)
  if type precond_deployment >/dev/null; then
    if ! precond_deployment; then
      log_error "precondition failed"
    fi
  elif type precond_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    if ! precond_deployment_$DEPLOYMENT_TYPE; then
      log_error "precondition failed"
    fi
  fi

  if type preinit_deployment >/dev/null; then
    preinit_deployment
  elif type preinit_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    preinit_deployment_$DEPLOYMENT_TYPE
  fi

  if [ -n "$REQUIRED_HOST_COMMANDS" ]; then
    log "checking host environment"
    ok=1
    for cmd in $REQUIRED_HOST_COMMANDS
    do
      if ! which $cmd >/dev/null 2>&1; then
        log_warn "Missing required command: $cmd"
        ok=0
      fi
    done
    if [ "$ok" -eq 0 ]; then
      ask_cleanup=0
      user_abort=1
      log_error "Please install missing packages (i.e. sudo apt install" $REQUIRED_PACKAGES ")"
    fi
  fi

  log_info "Initializing deployment ..."

  # if we intent to create LVM VG with the same name as on the host, rename the host one
  if [ -n "$LVM_VG" -a $lvm_rename_existing -eq 1 ]; then
    if vgs ${LVM_VG} >/dev/null 2>&1; then
      log_warn "Warning: renaming locally existing LVM VG $LVM_VG to ${LVM_VG}_molior_renamed"
      vgrename -A y $LVM_VG ${LVM_VG}_molior_renamed >&2
      exit_on_error "Error renaming LVM VG $LVM_VG"
    fi
  fi

  # create filesystems
  if type init_deployment >/dev/null; then
    init_deployment
  elif type init_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    init_deployment_$DEPLOYMENT_TYPE
  fi

  get_fsinfo

  if [ -n "$BASE_ROOTFS" ]; then
    log "extracting `basename $BASE_ROOTFS`"
    tar xf $BASE_ROOTFS -C $target
    exit_on_error "Error extracting '$BASE_ROOTFS'"

    mount_bootstrap

    log "updating APT database"
    chroot $target apt-get -o Acquire::Languages=none update >&2
    exit_on_error "apt-get update failed"

    # run postinst_deployment
    run_postinst
  elif [ $do_installation -eq 1 ]; then
    log_info "Installing base OS ..."
    bootstrap_deployment

    # run preinst_deployment
    if type preinst_deployment >/dev/null; then
      preinst_deployment
    elif type preinst_deployment_$DEPLOYMENT_TYPE >/dev/null; then
      preinst_deployment_$DEPLOYMENT_TYPE
    fi

    if [ $do_software_installation -eq 1 ]; then
      log_info "Installing software ..."
      install_deployment
    fi

    # run postinst_deployment, this will also install docker containers
    run_postinst

  else # $do_installation -eq 0
    # no installation, run only postinst_deployment
    run_postinst
  fi

  if [ -n "$MOLIOR_PROJECTINFO_FILE" ]; then
      mkdir -p `dirname $target/$MOLIOR_PROJECTINFO_FILE`
      echo $PROJECT/$VERSION > $target/$MOLIOR_PROJECTINFO_FILE
      exit_on_error "Error writing project/version to $target/$MOLIOR_PROJECTINFO_FILE"
  fi

  # install grub if requested
  if [ -n "$INSTALL_GRUB" ]; then
    if [ "$INSTALL_GRUB" = "yes" ]; then
      log_info "Installing grub bootloader ..."
      install_grub_bootloader
    fi
  fi

  cleanup_deployment
}

workflow_deployment()
{
  log_info "Creating deployment ..."

  # save rootfs alongside deployment
  if [ "$KEEP_ROOTFS" -eq 1 ]; then
      log "archiving rootfs"
      umount_bootstrap
      tar -C $WORK_DIR/root -cJf $WORK_DIR/rootfs.tar.xz .
      exit_on_error "error writing rootfs.tar.xz"
      mount_bootstrap
  fi

  if type finalize_deployment >/dev/null; then
    finalize_deployment
  elif type finalize_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    finalize_deployment_$DEPLOYMENT_TYPE
  fi

  if [ ! -f $WORK_DIR/$deployment ]; then
      log_error "Deployment not found: $WORK_DIR/$deployment"
  fi

  # compress if requested
  if [ $do_compress -eq 1 ]; then
    log "compressing $deployment$DEPLOYMENT_COMPRESSION_EXT"
    case $DEPLOYMENT_COMPRESSION in
        none)
        ;;
        xz)
           $PXZ_CMD $PXZ_EXTRA_OPTS -T `nproc --ignore 1` $WORK_DIR/$deployment >&2
           exit_on_error "Error compressing $deployment"
           deployment=$deployment.xz
        ;;
        gz|gzip)
           gzip $WORK_DIR/$deployment >&2
           exit_on_error "Error compressing $deployment"
           deployment=$deployment.gz
        ;;
    esac
  fi

  if [ $DEPLOYMENT_SHA256 -eq 1 ]; then
    if [ -z "$SHA256EXT" ]; then
      SHA256EXT=sha256
    fi
    cd $WORK_DIR
    sha256sum $deployment > $deployment.$SHA256EXT
    exit_on_error "Error sha256sum"
    cd - >/dev/null
    mv $WORK_DIR/$deployment.$SHA256EXT $CUR_DIR
    if [ -n "$SUDO_UID" -a -n "$SUDO_GID" ]; then
      chown $SUDO_UID:$SUDO_GID $CUR_DIR/$deployment.$SHA256EXT
    fi
  fi

  # move deployment to current dir, fix ownership if possible
  mv $WORK_DIR/$deployment $CUR_DIR/
  exit_on_error "Error moving deployment"

  if [ -n "$SUDO_UID" -a -n "$SUDO_GID" ]; then
    chown $SUDO_UID:$SUDO_GID $CUR_DIR/$deployment
  fi

  if [ "$KEEP_ROOTFS" -eq 1 ]; then
      mv $WORK_DIR/rootfs.tar.xz $CUR_DIR/rootfs_${PROJECT}_${VERSION}_${REVISION}_$VARIANT.tar.xz
      if [ -n "$SUDO_UID" -a -n "$SUDO_GID" ]; then
        chown $SUDO_UID:$SUDO_GID $CUR_DIR/rootfs_${PROJECT}_${VERSION}_${REVISION}_$VARIANT.tar.xz
      fi
  fi

  # deinitialize stuff
  if type deinit_deployment >/dev/null; then
    deinit_deployment
  elif type deinit_deployment_$DEPLOYMENT_TYPE >/dev/null; then
    deinit_deployment_$DEPLOYMENT_TYPE
  fi

  success=1
}

workflow_base

if [ -n "$BIND_MOUNTS" ]; then
  for m in $BIND_MOUNTS
  do
    from=`echo $m | cut -d: -f1`
    to=`echo $m | cut -d: -f2`
    opts=`echo $m | cut -d: -f3`
    if [ -z "$opts" ]; then
      opts="rw,noexec,nosuid,nodev"
    fi
    mkdir -p $target/$from $target/$to
    mount -o $opts,bind $target/$from $target/$to
  done
fi

workflow_deployment
